/**
 * This code was generated by @basketry/typescript@0.2.2
 *
 * Changes to this file may cause incorrect behavior and will be lost if
 * the code is regenerated.
 *
 * To make changes to the contents of this file:
 * 1. Edit src/schema.json
 * 2. Run the Basketry CLI
 *
 * About Basketry: https://basketry.io
 * About @basketry/typescript: https://basketry.io/docs/components/@basketry/typescript
 */

export type ApiKeySchemeInValue = 'header' | 'query' | 'cookie';

export type DisjunctionKind = 'inclusive' | 'exclusive';

/** The format of an array in an HTTP request or response. */
export type HttpArrayFormat = 'csv' | 'ssv' | 'tsv' | 'pipes' | 'multi';

export type HttpLocation = 'header' | 'query' | 'path' | 'formData' | 'body';

export type HttpVerb =
  | 'get'
  | 'post'
  | 'put'
  | 'patch'
  | 'delete'
  | 'head'
  | 'options'
  | 'trace';

/** The name of a primitive type. */
export type Primitive =
  | 'string'
  | 'number'
  | 'integer'
  | 'long'
  | 'float'
  | 'double'
  | 'boolean'
  | 'date'
  | 'date-time'
  | 'null'
  | 'binary'
  | 'untyped';

export type Severity = 'error' | 'warning' | 'info';

export type ApiKeyScheme = {
  kind: 'ApiKeyScheme';
  type: ApiKeySchemeType;
  deprecated?: TrueLiteral;
  name: StringLiteral;
  description?: StringLiteral[];
  parameter: StringLiteral;
  in: ApiKeySchemeIn;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
  meta?: MetaValue[];
};

export type ApiKeySchemeIn = {
  value: ApiKeySchemeInValue;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

export type ApiKeySchemeType = {
  value: 'apiKey';

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

/** A validation rule that specifies the maximum number of items in an array. */
export type ArrayMaxItemsRule = {
  kind: 'ValidationRule';
  id: 'ArrayMaxItems';
  max: NonNegativeIntegerLiteral;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

/** A validation rule that specifies the minimum number of items in an array. */
export type ArrayMinItemsRule = {
  kind: 'ValidationRule';
  id: 'ArrayMinItems';
  min: NonNegativeIntegerLiteral;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

/** A validation rule that specifies that all items in an array MUST be unique. */
export type ArrayUniqueItemsRule = {
  kind: 'ValidationRule';
  id: 'ArrayUniqueItems';
  required: boolean;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

export type BasicScheme = {
  kind: 'BasicScheme';
  type: BasicSchemeType;
  deprecated?: TrueLiteral;
  name: StringLiteral;
  description?: StringLiteral;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
  meta?: MetaValue[];
};

export type BasicSchemeType = {
  value: 'basic';

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

/**
 * The Basketry context provides metadata about the current Basketry execution
 * environment. This context is useful for resolving relative paths, debugging
 * plugin behavior, or adapting plugin behavior based on CLI invocation details.
 */
export type BasketryContext = {
  /** Absolute path to the Basketry configuration file that initiated this run. */
  configPath?: string;

  /**
   * Absolute path to the root of the Basketry project. All relative paths (e.g.
   * source files, outputs) are resolved against this directory.
   */
  projectDirectory: string;
};

/** Represents a boolean value exactly as it appears in the original source document. */
export type BooleanLiteral = {
  kind: 'BooleanLiteral';
  value: boolean;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

/** Represents a value whose type is defined elsewhere in the Service as a named type, enum, or union. */
export type ComplexValue = {
  kind: 'ComplexValue';

  /**
   * The name of a type, enum, or union defined in this Service. The casing MUST match
   * the casing of the referenced type, enum, or union definition exactly.
   */
  typeName: StringLiteral;

  /** A boolean value that indicates whether the value is an array. */
  isArray?: TrueLiteral;

  /**
   * Indicates whether the value MAY explicitly be set to `null`. When `true`, the
   * type definition allows `null` as a valid value in addition to what is specified
   * by `typeName`. Implementations MAY interpret `null` according to the closest
   * equivalent in the target language or platform. (This differs from `isOptional`,
   * where the value is not required to appear at all in the data structure or
   * message.)
   */
  isNullable?: TrueLiteral;

  /**
   * Indicates whether the value MAY be omitted entirely. When `true`, the value is
   * not required to appear in the data structure or message. (This differs from
   * `isNullable`, where the value is present but MAY explicitly be `null`.) If this
   * value is not present, tooling MUST consider the value to be required.
   */
  isOptional?: TrueLiteral;

  /**
   * A set of constraints that apply to the value, such as limits on length, numeric
   * range, or array size. These rules define additional validation beyond the basic
   * type definition and are distinct from rules that apply to a containing type.
   */
  rules: ValidationRule[];
};

/**
 * A Discriminated Union defines a member value that may be one of several possible
 * object types, with an explicit discriminator property whose value identifies
 * which type is present. This approach allows implementations to unambiguously
 * determine the type at runtime without inspecting the full structure of the value.
 * Discriminated unions are commonly used when member types share overlapping shapes
 * or when reliable deserialization across languages and tools is required.
 */
export type DiscriminatedUnion = {
  kind: 'DiscriminatedUnion';

  /**
   * The name of the union. This name MUST be unique within the Service across all
   * other types, enums, and unions. This value MAY be represented in any casing.
   * Generators MUST NOT assume any particular casing for this value and SHOULD
   * represent it in a language-idiomatic way.
   */
  name: StringLiteral;

  /**
   * An array of strings that describe the union. Each item in the array SHOULD be
   * considered a separate paragraph. These values MAY include Markdown formatting.
   */
  description?: StringLiteral[];

  /**
   * The name of the discriminator property. This property MUST exist in all union
   * member types and MUST use identical casing across all of them.
   */
  discriminator: StringLiteral;

  /** An array of the possible member values that make up the union. */
  members: ComplexValue[];

  /** A boolean value that indicates whether the union is deprecated. */
  deprecated?: TrueLiteral;

  /** The encoded location of the union in the source document(s). */
  loc?: string;

  /** An array of metadata values for the union. */
  meta?: MetaValue[];
};

export type DisjunctionKindLiteral = {
  kind: 'DisjunctionKindLiteral';

  /**
   * In an inclusive disjunction, a value MUST fully match at least one union member
   * and MAY also match others. In an exclusive disjunction, a value MUST fully match
   * exactly one union member and MUST NOT match any others.
   */
  value: DisjunctionKind;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

/**
 * An Enum defines a named set of constant values that represent all valid options
 * for a particular member value.
 */
export type Enum = {
  kind: 'Enum';

  /**
   * The name of the enum. This name MUST be unique within the Service across all
   * other types, enums, and unions. This value MAY be represented in any casing.
   * Generators MUST NOT assume any particular casing for this value and SHOULD
   * represent it in a language-idiomatic way.
   */
  name: StringLiteral;

  /**
   * An array of strings that describe the enum. Each item in the array SHOULD be
   * considered a separate paragraph. These values MAY include Markdown formatting.
   */
  description?: StringLiteral[];

  /**
   * An array of the constant values that make up the enum. Each member defines a
   * single allowed value along with its optional description.
   */
  members: EnumMember[];

  /** A boolean value that indicates whether the enum is deprecated. */
  deprecated?: TrueLiteral;

  /** The encoded location of the enum in the source document(s). */
  loc?: string;

  /** An array of metadata values for the enum. */
  meta?: MetaValue[];
};

/** Represents a single constant value within an enum. */
export type EnumMember = {
  kind: 'EnumMember';

  /** The constant value that represents the enum member. This value MUST be unique within the enum. */
  content: StringLiteral;

  /**
   * An array of strings that describe the enum member. Each item in the array SHOULD
   * be considered a separate paragraph. These values MAY include Markdown formatting.
   */
  description?: StringLiteral[];

  /** A boolean value that indicates whether the enum member is deprecated. */
  deprecated?: TrueLiteral;

  /** The encoded location of the enum member in the source document(s). */
  loc?: string;

  /** An array of metadata values for the enum member. */
  meta?: MetaValue[];
};

/**
 * The `ErrorResponse` object defines the structure of a JSON-RPC response returned
 * when a request fails. It adheres to the [JSON-RPC 2.0
 * specification](https://www.jsonrpc.org/specification) and conveys error
 * information instead of a result.
 */
export type ErrorResponse = {
  /** The JSON-RPC protocol version. */
  jsonrpc: '2.0';

  /**
   * Echoes the ID of the corresponding request. Used by the caller to correlate
   * responses. If the request could not be parsed, this value SHOULD be `null`.
   */
  id: ErrorResponseId;

  /** The error object providing details about the failure. */
  error: RpcError;
};

/** The `File` object represents a single file produced by a generator. */
export type File = {
  /**
   * The path to the file, relative to the project directory. This MUST include the
   * file name and extension. The array form allows paths to be represented in a
   * normalized, platform-independent manner (e.g., ["src", "models", "user.ts"]).
   */
  path: string[];

  /**
   * The complete textual contents of the file. Generators MUST encode the entire file
   * body as a UTF-8 string.
   */
  contents: string;
};

/**
 * The `GenerateParams` object defines the input parameters passed to the
 * `basketry.generate` method. It provides the generator with the service definition
 * to render.
 */
export type GenerateParams = {
  /**
   * Contains the parsed `Service` and generator-specific options. This is the primary
   * input for code generation.
   */
  context: GeneratorContext;

  /** Contains runtime metadata. */
  basketry: BasketryContext;
};

/**
 * The `GenerateRequest` object defines the structure of a JSON-RPC request for
 * invoking the `basketry.generate` method. This method is called by the Basketry
 * CLI or orchestrator to execute one or more generators against a parsed `Service`.
 * It adheres to the [JSON-RPC 2.0
 * specification](https://www.jsonrpc.org/specification) and includes metadata and
 * parameters needed to perform the generation operation.
 */
export type GenerateRequest = {
  /** The JSON-RPC protocol version. */
  jsonrpc: '2.0';

  /**
   * A unique identifier for this request. The response from the plugin will include
   * this same ID, allowing the caller to correlate requests and responses.
   */
  id: RequestId;

  /** The name of the RPC method to invoke. */
  method: 'basketry.generate';

  /** The parameters specific to the generate operation. */
  params: GenerateParams;
};

/**
 * The `GenerateResponse` object represents the response payload returned from the
 * `basketry.generate` method. It adheres to the [JSON-RPC 2.0
 * specification](https://www.jsonrpc.org/specification) and contains the files
 * produced by the generator.
 */
export type GenerateResponse = {
  /** The JSON-RPC protocol version. */
  jsonrpc: '2.0';

  /** Echoes the ID of the corresponding request. Used by the caller to correlate responses. */
  id: RequestId;

  /** The outcome of the generation operation, including all files produced. */
  result: GenerateResult;
};

/** The `GenerateResult` object encapsulates the output of a generator. */
export type GenerateResult = {
  /** An array of files produced by the generator. If no files are generated, this array MUST be empty. */
  files: File[];
};

/**
 * The `GeneratorContext` object provides the inputs required by a generator to
 * produce output artifacts.
 */
export type GeneratorContext = {
  /**
   * The intermediate representation (IR) of the service, produced by a parser. This
   * is the input used by the generator to create code, documentation, or other
   * artifacts.
   */
  service: Service;

  /**
   * Generator-specific configuration values. The structure and semantics of this
   * field are defined by the generator itself. If omitted, empty, or improperly
   * structured, the generator MUST apply its default behavior
   */
  options?: any;
};

/**
 * Represents the format of an array in an HTTP request or response as it appears in
 * the original source document.
 */
export type HttpArrayFormatLiteral = {
  kind: 'HttpArrayFormatLiteral';
  value: HttpArrayFormat;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

/** Represents the location of an HTTP parameter as it appears in the original source document. */
export type HttpLocationLiteral = {
  kind: 'HttpLocationLiteral';
  value: HttpLocation;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

export type HttpMethod = {
  kind: 'HttpMethod';
  name: StringLiteral;
  verb: HttpVerbLiteral;
  parameters: HttpParameter[];
  successCode: HttpStatusCodeLiteral;
  requestMediaTypes: StringLiteral[];
  responseMediaTypes: StringLiteral[];

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

export type HttpParameter = {
  kind: 'HttpParameter';
  name: StringLiteral;
  location: HttpLocationLiteral;
  arrayFormat?: HttpArrayFormatLiteral;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

export type HttpRoute = {
  kind: 'HttpRoute';
  pattern: StringLiteral;
  methods: HttpMethod[];

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

/** Represents an HTTP status code as it appears in the original source document. */
export type HttpStatusCodeLiteral = {
  kind: 'HttpStatusCodeLiteral';
  value: number;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

/** Represents an HTTP verb string as it appears in the original source document. */
export type HttpVerbLiteral = {
  kind: 'HttpVerbLiteral';

  /**
   * The HTTP verb as a lowercase string. Generators MAY represent this value in a
   * language- or platform-idiomatic casing.
   */
  value: HttpVerb;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

/** Represents an integer value exactly as it appears in the original source document. */
export type IntegerLiteral = {
  kind: 'IntegerLiteral';
  value: number;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

/**
 * An Interface defines a cohesive set of related methods that collectively
 * represent a functional contract within a service. Interfaces act as the primary
 * grouping mechanism for operations and are protocol-agnostic by default. They
 * provide a stable, language-neutral abstraction of service capabilities, ensuring
 * that tooling can target a wide range of programming languages and frameworks
 * without losing semantic meaning.
 */
export type Interface = {
  kind: 'Interface';

  /**
   * The name of the interface. This name MUST be unique within the Service. This
   * value MAY be represented in any casing. Generators MUST NOT assume any particular
   * casing for this value and SHOULD represent it in a language-idiomatic way.
   */
  name: StringLiteral;

  /**
   * An array of strings that describe the interface. Each item in the array SHOULD be
   * considered a separate paragraph. These values MAY include Markdown formatting.
   */
  description?: StringLiteral[];

  /** An array of methods defined by this interface. */
  methods: Method[];

  /**
   * Any protocol-specific information about the interface. This information is not
   * part of the core interface structure and definition, but MAY be used by tooling
   * to generate code for specific protocols.
   */
  protocols?: Protocols;

  /** A boolean value that indicates whether the interface is deprecated. */
  deprecated?: TrueLiteral;

  /** An array of metadata values for the interface. */
  meta?: MetaValue[];
};

/** Defines the allowed shape and constraints for keys in Map Properties. */
export type MapKey = {
  kind: 'MapKey';

  /** The type definition for the map’s keys, which MAY be either a primitive or complex value. */
  value: MemberValue;

  /** The encoded location of the map key in the source document(s). */
  loc?: string;

  /** An array of metadata values for the map key. */
  meta?: MetaValue[];
};

/**
 * Map properties define the allowed shape for values associated with dynamically
 * named keys in a type. They are used when the set of field names is not known in
 * advance, allowing instances of the type to contain any number of keys that
 * conform to a shared schema. Unlike properties, which represent explicitly named
 * fields that are the same for all instances of a type, map properties describe
 * rules for dynamically named fields that may vary between instances.
 */
export type MapProperties = {
  kind: 'MapProperties';

  /**
   * The shape of the keys that are allowed in the map. This value defines the data
   * shape and constraints for the map keys.
   */
  key: MapKey;

  /**
   * An array of key names that MUST be present in every instance of the map. Each
   * entry specifies a required key that MUST conform to the map’s value definition.
   * The array MAY be empty.
   */
  requiredKeys: StringLiteral[];

  /**
   * The shape of the values that are allowed in the map. This value defines the data
   * shape and constraints for the map values.
   */
  value: MapValue;

  /** The encoded location of the map properties in the source document(s). */
  loc?: string;

  /** An array of metadata values for the map properties. */
  meta?: MetaValue[];
};

/** Defines the allowed shape and constraints for values in Map Properties. */
export type MapValue = {
  kind: 'MapValue';

  /** The type definition for the map’s values, which MAY be either a primitive or complex value. */
  value: MemberValue;

  /** The encoded location of the map key in the source document(s). */
  loc?: string;

  /** An array of metadata values for the map key. */
  meta?: MetaValue[];
};

/** Metadata in the form of a key-value pair. */
export type MetaValue = {
  kind: 'MetaValue';

  /** The key of the metadata value. */
  key: StringLiteral;

  /** An untyped literal value. Implementations MUST NOT assume any particular type for this value. */
  value: UntypedLiteral;
};

/**
 * A Method defines a single operation that can be performed on a service. Methods
 * are the primary means of interacting with a service and are associated with a
 * specific interface. They define the input parameters, output values, and any
 * security requirements for executing the operation.
 */
export type Method = {
  kind: 'Method';

  /**
   * The name of the method. This name MUST be unique within the Service. This value
   * MAY be represented in any casing. Generators MUST NOT assume any particular
   * casing for this value and SHOULD represent it in a language-idiomatic way.
   */
  name: StringLiteral;

  /**
   * An array of strings that describe the interface. Each item in the array SHOULD be
   * considered a separate paragraph. These values MAY include Markdown formatting.
   */
  description?: StringLiteral[];

  /**
   * An array of parameters that are required for the method. Each parameter defines
   * its own name, value definition, and optional constraints.
   */
  parameters: Parameter[];
  security: SecurityOption[];

  /** The value that is returned by the method. This value is defined by the method’s return type. */
  returns?: ReturnValue;

  /** A boolean value that indicates whether the method is deprecated. */
  deprecated?: TrueLiteral;

  /** The encoded location of the method in the source document(s). */
  loc?: string;

  /** An array of metadata values for the method. */
  meta?: MetaValue[];
};

/** Represents a non-empty string value exactly as it appears in the original source document. */
export type NonEmptyStringLiteral = {
  kind: 'NonEmptyStringLiteral';
  value: string;

  /** The location of this in the doc. */
  loc?: string;
};

/** Represents a non-negative integer value exactly as it appears in the original source document. */
export type NonNegativeIntegerLiteral = {
  kind: 'NonNegativeIntegerLiteral';
  value: number;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

/** Represents a non-negative numeric value exactly as it appears in the original source document. */
export type NonNegativeNumberLiteral = {
  kind: 'NonNegativeNumberLiteral';
  value: number;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

/** Represents a null value exactly as it appears in the original source document. */
export type NullLiteral = {
  kind: 'NullLiteral';
  value: any;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

/** A validation rule that specifies a number that MUST be greater than or equal to a given value. */
export type NumberGteRule = {
  kind: 'ValidationRule';
  id: 'NumberGTE';
  value: NumberLiteral;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

/** A validation rule that specifies a number that MUST be greater than a given value. */
export type NumberGtRule = {
  kind: 'ValidationRule';
  id: 'NumberGT';
  value: NumberLiteral;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

/** Represents a numeric value exactly as it appears in the original source document. */
export type NumberLiteral = {
  kind: 'NumberLiteral';
  value: number;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

/** A validation rule that specifies a number that MUST be less than or equal to a given value. */
export type NumberLteRule = {
  kind: 'ValidationRule';
  id: 'NumberLTE';
  value: NumberLiteral;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

/** A validation rule that specifies a number that MUST be less than a given value. */
export type NumberLtRule = {
  kind: 'ValidationRule';
  id: 'NumberLT';
  value: NumberLiteral;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

/** A validation rule that specifies a multiple of a number. */
export type NumberMultipleOfRule = {
  kind: 'ValidationRule';
  id: 'NumberMultipleOf';
  value: NonNegativeNumberLiteral;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

export type OAuth2AuthorizationCodeFlow = {
  kind: 'OAuth2AuthorizationCodeFlow';
  type: OAuth2AuthorizationCodeFlowType;
  deprecated?: TrueLiteral;
  authorizationUrl: StringLiteral;
  tokenUrl: StringLiteral;
  refreshUrl?: StringLiteral;
  scopes: OAuth2Scope[];

  /** The encoded location of this node in the source document(s). */
  loc?: string;
  meta?: MetaValue[];
};

export type OAuth2AuthorizationCodeFlowType = {
  value: 'authorizationCode';

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

export type OAuth2ClientCredentialsFlow = {
  kind: 'OAuth2ClientCredentialsFlow';
  type: OAuth2ClientCredentialsFlowType;
  deprecated?: TrueLiteral;
  tokenUrl: StringLiteral;
  refreshUrl?: StringLiteral;
  scopes: OAuth2Scope[];

  /** The encoded location of this node in the source document(s). */
  loc?: string;
  meta?: MetaValue[];
};

export type OAuth2ClientCredentialsFlowType = {
  value: 'clientCredentials';

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

export type OAuth2ImplicitFlow = {
  kind: 'OAuth2ImplicitFlow';
  type: OAuth2ImplicitFlowType;
  deprecated?: TrueLiteral;
  authorizationUrl: StringLiteral;
  refreshUrl?: StringLiteral;
  scopes: OAuth2Scope[];

  /** The encoded location of this node in the source document(s). */
  loc?: string;
  meta?: MetaValue[];
};

export type OAuth2ImplicitFlowType = {
  value: 'implicit';

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

export type OAuth2PasswordFlow = {
  kind: 'OAuth2PasswordFlow';
  type: OAuth2PasswordFlowType;
  deprecated?: TrueLiteral;
  tokenUrl: StringLiteral;
  refreshUrl?: StringLiteral;
  scopes: OAuth2Scope[];

  /** The encoded location of this node in the source document(s). */
  loc?: string;
  meta?: MetaValue[];
};

export type OAuth2PasswordFlowType = {
  value: 'password';

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

export type OAuth2Scheme = {
  kind: 'OAuth2Scheme';
  type: OAuth2SchemeType;
  deprecated?: TrueLiteral;
  name: StringLiteral;
  description?: StringLiteral[];
  flows: OAuth2Flow[];

  /** The encoded location of this node in the source document(s). */
  loc?: string;
  meta?: MetaValue[];
};

export type OAuth2SchemeType = {
  value: 'oauth2';

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

export type OAuth2Scope = {
  kind: 'OAuth2Scope';
  name: StringLiteral;
  description: StringLiteral[];
  deprecated?: TrueLiteral;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
  meta?: MetaValue[];
};

export type ObjectAdditionalPropertiesRule = {
  kind: 'ObjectValidationRule';
  id: 'ObjectAdditionalProperties';
  forbidden: TrueLiteral;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

/**
 * A validation rule that specifies the maximum number of properties on an object.
 * This rule MAY be ignored by tooling if the object type does not define any Map
 * Properties.
 */
export type ObjectMaxPropertiesRule = {
  kind: 'ObjectValidationRule';
  id: 'ObjectMaxProperties';
  max: NonNegativeIntegerLiteral;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

/**
 * A validation rule that specifies the minimum number of properties on an object.
 * This rule MAY be ignored by tooling if the object type does not define any Map
 * Properties.
 */
export type ObjectMinPropertiesRule = {
  kind: 'ObjectValidationRule';
  id: 'ObjectMinProperties';
  min: NonNegativeIntegerLiteral;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

/**
 * A Parameter defines an input value accepted by a method. Parameters define the
 * contract for the information a method caller MUST (or MAY) provide, ensuring
 * consistent behavior across all implementations of the service.
 */
export type Parameter = {
  kind: 'Parameter';

  /**
   * The name of the parameter. This name MUST be unique within the method. This value
   * MAY be represented in any casing. Generators MUST NOT assume any particular
   * casing for this value and SHOULD represent it in a language-idiomatic way.
   */
  name: StringLiteral;

  /**
   * An array of strings that describe the parameter. Each item in the array SHOULD be
   * considered a separate paragraph. These values MAY include Markdown formatting.
   */
  description?: StringLiteral[];

  /** The value of the parameter. This value defines the data shape and constraints for the parameter. */
  value: MemberValue;

  /** A boolean value that indicates whether the parameter is deprecated. */
  deprecated?: TrueLiteral;

  /** The encoded location of the parameter in the source document(s). */
  loc?: string;

  /** An array of metadata values for the parameter. */
  meta?: MetaValue[];
};

/**
 * The input payload passed to a plugin’s `basketry.parse` method. This object
 * contains both the raw content to be parsed and metadata about the execution
 * environment. Plugin authors should use this object to extract all necessary
 * information to perform the parse operation.
 */
export type ParseParams = {
  /**
   * Contains the source text and its associated file path. This is the content the
   * plugin is expected to parse.
   */
  context: ParserContext;

  /** Contains runtime metadata. */
  basketry: BasketryContext;
};

/**
 * The Parser context object provides the core input to the plugin's parser: the raw
 * source file and its path. This context isolates the entrypoint file that should
 * be parsed and serves as the root for resolving any references to additional files
 * (if applicable).
 */
export type ParserContext = {
  /** The relative path to the entrypoint file, from the root of the project directory. */
  sourcePath: string;

  /** The full text content of the entrypoint file. */
  sourceContent: string;
};

/**
 * The `ParseRequest` object defines the structure of a JSON-RPC request for
 * invoking the `basketry.parse` method. This method is called by the Basketry CLI
 * or orchestrator to initiate parsing of one or more input files by a plugin. It
 * adheres to the [JSON-RPC 2.0
 * specification](https://www.jsonrpc.org/specification) and includes metadata and
 * parameters needed to perform the parse operation.
 */
export type ParseRequest = {
  /** The JSON-RPC protocol version. */
  jsonrpc: '2.0';

  /**
   * A unique identifier for this request. The response from the plugin will include
   * this same ID, allowing the caller to correlate requests and responses.
   */
  id: RequestId;

  /** The name of the RPC method to invoke. */
  method: 'basketry.parse';

  /** The parameters specific to the parse operation. */
  params: ParseParams;
};

/**
 * The Parse response object represents the response payload returned from a
 * plugin’s `basketry.parse` method. It adheres to the [JSON-RPC 2.0
 * specification](https://www.jsonrpc.org/specification) and contains the result of
 * the parsing operation including both the produced service definition and any
 * violations encountered.
 */
export type ParseResponse = {
  /** The JSON-RPC protocol version. */
  jsonrpc: '2.0';

  /** Echoes the ID of the corresponding request. Used by the caller to correlate responses. */
  id: RequestId;

  /**
   * The result of the parse operation, including a service definition (if successful)
   * and a list of violations (if any).
   */
  result: ParseResult;
};

/**
 * The parse result object encapsulates the output of a parsing operation. This
 * includes the intermediate representation (IR) of the parsed service and any
 * violations reported during the parsing process.
 */
export type ParseResult = {
  /**
   * The parsed intermediate representation of the service. This is the structured
   * output that downstream Basketry components will consume. This field is typically
   * `undefined` if parsing fails entirely
   */
  service?: Service;

  /**
   * A list of violations encountered during parsing. Even if parsing is successful,
   * this array may include warnings or informational messages to aid in debugging or
   * quality assurance. If no issues were found, this should be an empty array.
   */
  violations: Violation[];
};

/** The `Position` object defines a single point in a source document. */
export type Position = {
  /** The 1-based line number of the position. The first line in a document is `1`. */
  line: number;

  /** The 1-based column number of the position within the line. The first column is `1`. */
  column: number;

  /** The 0-based character offset from the start of the document. The first character is `0`. */
  offset: number;
};

export type PrimitiveLiteral = {
  kind: 'PrimitiveLiteral';
  value: Primitive;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

/**
 * Represents a value whose type is one of the built-in primitives (such as string,
 * number, boolean, or null). Unlike a complex value, a primitive value does not
 * reference other types, enums, or unions—it directly describes a base data type.
 */
export type PrimitiveValue = {
  kind: 'PrimitiveValue';

  /** The name of the primitive type. */
  typeName: PrimitiveLiteral;

  /** A boolean value that indicates whether the value is an array. */
  isArray?: TrueLiteral;

  /**
   * Indicates whether the value MAY explicitly be set to `null`. When `true`, the
   * type definition allows `null` as a valid value in addition to what is specified
   * by `typeName`. Implementations MAY interpret `null` according to the closest
   * equivalent in the target language or platform. (This differs from `isOptional`,
   * where the value is not required to appear at all in the data structure or
   * message.)
   */
  isNullable?: TrueLiteral;

  /**
   * Indicates whether the value MAY be omitted entirely. When `true`, the value is
   * not required to appear in the data structure or message. (This differs from
   * `isNullable`, where the value is present but MAY explicitly be `null`.) If this
   * value is not present, tooling MUST consider the value to be required.
   */
  isOptional?: TrueLiteral;

  /**
   * A single, fixed allowed value. This value MUST be compatible with the type
   * specified by `typeName`. When defined, this value is the only valid value for the
   * field, and tooling or validation MUST reject any other value.
   */
  constant?: PrimitiveValueConstant;

  /**
   * A value to be assumed or applied when none is provided. This value MUST be
   * compatible with the type specified by `typeName`. A default does not restrict
   * other valid values—it simply acts as the initial value when the field is omitted
   */
  default?: PrimitiveValueDefault;

  /**
   * A set of constraints that apply to the value, such as limits on length, numeric
   * range, or array size. These rules define additional validation beyond the basic
   * type definition and are distinct from rules that apply to a containing type.
   */
  rules: ValidationRule[];
};

/**
 * A Property defines a named field within a type, representing a fixed part of that
 * type’s structure. Each property specifies the field’s name, its data shape, and
 * optional descriptive context. Properties are used when the set of field names is
 * known in advance and does not vary between instances of the type.
 */
export type Property = {
  kind: 'Property';

  /**
   * The name of the property. This name MUST be unique within a type. This value MAY
   * be represented in any casing. Generators MUST NOT assume any particular casing
   * for this value and SHOULD represent it in a language-idiomatic way.
   */
  name: StringLiteral;

  /**
   * An array of strings that describe the property. Each item in the array SHOULD be
   * considered a separate paragraph. These values MAY include Markdown formatting.
   */
  description?: StringLiteral[];

  /** The value of the property. This value defines the data shape and constraints for the property. */
  value: MemberValue;

  /** A boolean value that indicates whether the property is deprecated. */
  deprecated?: TrueLiteral;

  /** The encoded location of the property in the source document(s). */
  loc?: string;

  /** An array of metadata values for the property. */
  meta?: MetaValue[];
};

export type Protocols = {
  kind: 'InterfaceProtocols';
  http?: HttpRoute[];
};

/**
 * The `Range` object defines a span within a source document. A `Range` is the
 * decoded representation of the `loc` property found in the `Service` IR and
 * provides precise information about where a violation or element occurs in the
 * source text.
 */
export type Range = {
  /** The position of the first character in the range. */
  start: Position;

  /** The position of the last character in the range. */
  end: Position;
};

/**
 * A ReturnValue defines the output produced by a method, specifying the value’s
 * data shape and constraints.
 */
export type ReturnValue = {
  kind: 'ReturnValue';

  /**
   * The value that is returned by the method. This value defines the data shape and
   * constraints for the return value.
   */
  value: MemberValue;

  /** The encoded location of the return value in the source document(s). */
  loc?: string;

  /** An array of metadata values for the return value. */
  meta?: MetaValue[];
};

export type RpcError = {
  /**
   * A machine-readable error code that identifies the type of error. Codes SHOULD
   * follow the [JSON-RPC 2.0 standard error
   * codes](https://www.jsonrpc.org/specification#error_object) when applicable, but
   * MAY include custom values for Basketry-specific conditions.
   */
  code: number;

  /**
   * A short human-readable description of the error. The message SHOULD be limited to
   * a concise single sentence.
   */
  message: string;

  /**
   * An optional value that contains additional information about the error. The
   * structure of this value MAY be determined by the plugin.
   */
  data?: any;
};

/** The `RuleContext` object provides the inputs that a rule evaluates during validation. */
export type RuleContext = {
  /**
   * The intermediate representation (IR) of the service, produced by a parser. This
   * is the input that rules validate against.
   */
  service: Service;

  /**
   * Rule-specific configuration values. The structure and semantics of this field are
   * defined by the rule itself. If omitted, empty, or improperly structured, the rule
   * MUST apply its default behavior
   */
  options?: any;
};

export type SecurityOption = {
  kind: 'SecurityOption';
  schemes: SecurityScheme[];

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

/**
 * The `Service` object is the root of a Basketry Intermediate Representation (IR)
 * document. It defines the core attributes of an API service, including its name,
 * version, source documents, and all types and interfaces it contains. The
 * `Service` object provides a canonical, language-agnostic model of the service
 * definition that plugins such as generators and rules can consume without
 * requiring access to the original source files.
 */
export type Service = {
  kind: 'Service';

  /**
   * This string MUST be the version number of the Basketry Specification that the
   * Intermediate Representation uses. The `basketry` field SHOULD be used by tooling
   * to interpret the IR document. This is not related to the Service `majorVersion`
   * string.
   */
  basketry: '0.2';

  /** The title of the service */
  title: StringLiteral;

  /** The major version of the Service (which is distinct from the Basketry Specification version). */
  majorVersion: IntegerLiteral;

  /**
   * An array of paths to the original source documents for this service. These paths
   * are relative to the directory of the config file that produced the IR. All
   * locations in the Intermediate Representation refer to ranges within these source
   * documents.
   */
  sourcePaths: string[];

  /** An array of Interfaces defined in this Service. */
  interfaces: Interface[];

  /** An array of Types defined in this Service. */
  types: Type[];

  /** An array of Enums defined in this Service. */
  enums: Enum[];

  /** An array of Unions defined in this Service. */
  unions: Union[];

  /** The encoded location of the service in the source document(s). */
  loc?: string;

  /** An array of metadata values for the service. */
  meta?: MetaValue[];
};

/**
 * A Simple Union defines a member value that may be one of several possible
 * primitive or complex types, without any additional field to indicate which type
 * is in use. Implementations must determine the actual type based on the value
 * itself. Simple unions are typically used for cases where the set of possible
 * types is small and easily distinguishable without an explicit discriminator.
 */
export type SimpleUnion = {
  kind: 'SimpleUnion';

  /**
   * The name of the union. This name MUST be unique within the Service across all
   * other types, enums, and unions. This value MAY be represented in any casing.
   * Generators MUST NOT assume any particular casing for this value and SHOULD
   * represent it in a language-idiomatic way.
   */
  name: StringLiteral;

  /**
   * An array of strings that describe the union. Each item in the array SHOULD be
   * considered a separate paragraph. These values MAY include Markdown formatting.
   */
  description?: StringLiteral[];

  /** An array of the possible member values that make up the union. */
  members: MemberValue[];

  /**
   * Indicates whether the union’s members are inclusive or exclusive. In an inclusive
   * disjunction, a value MUST fully match at least one member and MAY also match
   * others. In an exclusive disjunction, a value MUST fully match exactly one member
   * and MUST NOT match any others. If this value is not present, tooling SHOULD
   * consider the union to be inclusive.
   */
  disjunction?: DisjunctionKindLiteral;

  /** A boolean value that indicates whether the union is deprecated. */
  deprecated?: TrueLiteral;

  /** The encoded location of the union in the source document(s). */
  loc?: string;

  /** An array of metadata values for the union. */
  meta?: MetaValue[];
};

/**
 * A validation rule that specifies a format that a string SHOULD conform to. This
 * rule is distinct from `StringPattern` because it allows for additional named
 * formats beyond regular expressions. Implementations SHOULD interpret the format
 * according to the closest equivalent in the target language or platform.
 */
export type StringFormatRule = {
  kind: 'ValidationRule';
  id: 'StringFormat';
  format: NonEmptyStringLiteral;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

/** Represents a string value exactly as it appears in the original source document. */
export type StringLiteral = {
  kind: 'StringLiteral';
  value: string;

  /** The location of this in the doc. */
  loc?: string;
};

/** A validation rule that specifies the maximum length of a string. */
export type StringMaxLengthRule = {
  kind: 'ValidationRule';
  id: 'StringMaxLength';
  length: NonNegativeIntegerLiteral;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

/** A validation rule that specifies the minimum length of a string. */
export type StringMinLengthRule = {
  kind: 'ValidationRule';
  id: 'StringMinLength';
  length: NonNegativeIntegerLiteral;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

/** A validation rule that specifies a regular expression pattern that a string MUST match. */
export type StringPatternRule = {
  kind: 'ValidationRule';
  id: 'StringPattern';
  pattern: NonEmptyStringLiteral;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

/** Represents a boolean `true` value exactly as it appears in the original source document. */
export type TrueLiteral = {
  kind: 'TrueLiteral';
  value: true;

  /** The encoded location of this node in the source document(s). */
  loc?: string;
};

/**
 * A Type defines the structure of a data shape used within a service. Types are
 * reusable, named contracts that describe how data is organized and validated
 * across interfaces and methods. They provide a stable, language-neutral
 * representation of complex data models, allowing tooling to interact iwth strongly
 * typed artifacts in any target language while preserving the semantics and
 * constraints defined in the original service description
 */
export type Type = {
  kind: 'Type';

  /**
   * The name of the type. This name MUST be unique within the Service across all
   * other types, enums, and unions. This value MAY be represented in any casing.
   * Generators MUST NOT assume any particular casing for this value and SHOULD
   * represent it in a language-idiomatic way.
   */
  name: StringLiteral;

  /**
   * An array of strings that describe the type. Each item in the array SHOULD be
   * considered a separate paragraph. These values MAY include Markdown formatting.
   */
  description?: StringLiteral[];

  /** A boolean value that indicates whether the type is deprecated. */
  deprecated?: TrueLiteral;

  /**
   * An array of named properties that make up the structure of the type. Each
   * property has its own name, value definition, and optional constraints. Properties
   * SHOULD be used when the type’s structure is defined by a fixed set of known field
   * names.
   */
  properties: Property[];

  /**
   * An optional set of allowed key and value shapes when the type represents a
   * dynamic map or dictionary rather than a fixed set of fields. Map properties
   * SHOULD be used when the type’s structure is defined by arbitrary keys whose
   * values share a common schema.
   */
  mapProperties?: MapProperties;

  /**
   * A set of constraints that apply to the overall structure of the type. These rules
   * are specific to the type itself and are distinct from rules that apply to
   * property definitions.
   */
  rules: ObjectValidationRule[];

  /** The encoded location of the type in the source document(s). */
  loc?: string;

  /** An array of metadata values for the type. */
  meta?: MetaValue[];
};

/** An untyped literal value. Implementations MUST NOT assume any particular type for this value. */
export type UntypedLiteral = {
  kind: 'UntypedLiteral';
  value: any;

  /** The encoded location of the untyped literal value in the source document(s). */
  loc?: string;
};

/** The `ValidateParams` object defines the input parameters passed to the `basketry.validate` method. */
export type ValidateParams = {
  /** Contains the `Service` to be validated and any rule-specific options. */
  context: RuleContext;

  /** Contains runtime metadata. */
  basketry: BasketryContext;
};

/**
 * The `ValidateRequest` object defines the structure of a JSON-RPC request for
 * invoking the `basketry.validate` method. This method is called by the Basketry
 * CLI or orchestrator to execute one or more rules against a parsed `Service`. It
 * adheres to the [JSON-RPC 2.0
 * specification](https://www.jsonrpc.org/specification) and includes metadata and
 * parameters needed to perform the validation operation.
 */
export type ValidateRequest = {
  /** The JSON-RPC protocol version. */
  jsonrpc: '2.0';

  /**
   * A unique identifier for this request. The response from the plugin will include
   * this same ID, allowing the caller to correlate requests and responses.
   */
  id: RequestId;

  /** The name of the RPC method to invoke. */
  method: 'basketry.validate';

  /** The parameters specific to the validate operation. */
  params: ValidateParams;
};

/**
 * The `ValidateResponse` object represents the response payload returned from the
 * `basketry.validate` method. It adheres to the [JSON-RPC 2.0
 * specification](https://www.jsonrpc.org/specification) and contains the result of
 * executing a rule against a service definition.
 */
export type ValidateResponse = {
  /** The JSON-RPC protocol version. */
  jsonrpc: '2.0';

  /** Echoes the ID of the corresponding request. Used by the caller to correlate responses. */
  id: RequestId;

  /** The outcome of the validation, including all violations produced by the rule. */
  result: ValidateResult;
};

/** The `ValidateResult` object encapsulates the outcome of a rule’s validation run. */
export type ValidateResult = {
  /** A list of violations produced by the rule. If no violations are found, this array MUST be empty. */
  violations: Violation[];
};

/**
 * A Violation represents a problem encountered during parsing or rule evaluation.
 * It includes metadata to help developers and systems pinpoint and understand
 * issues within the source document.
 */
export type Violation = {
  /**
   * The path to the source document that contains the violation. This path is
   * relative to the project directory.
   */
  sourcePath: string;

  /** The range of the violation in the source document. */
  range: Range;

  /**
   * A human-readable explanation of the violation, suitable for display in CLI
   * output, logs, or developer tools.
   */
  message: string;

  /**
   * Indicates the impact of the violation. Use `"error"` for blocking issues,
   * `"warning"` for non-blocking recommendations, and `"info"` for helpful guidance.
   */
  severity: Severity;

  /**
   * A unique identifier for the type of violation. This value SHOULD be a short,
   * machine-readable string that can be used to identify the violation.
   */
  code: string;

  /**
   * A URL that provides additional documentation or context for the violation. MUST
   * be a valid URI if provided. Useful for pointing to rule definitions, spec
   * references, or troubleshooting guides.
   */
  link?: string;
};

/**
 * Echoes the ID of the corresponding request. Used by the caller to correlate
 * responses. If the request could not be parsed, this value SHOULD be `null`.
 */
export type ErrorResponseId = string | number | any;

export type MemberValue = PrimitiveValue | ComplexValue;

export function isPrimitiveValue(obj: MemberValue): obj is PrimitiveValue {
  return obj.kind === 'PrimitiveValue';
}

export function isComplexValue(obj: MemberValue): obj is ComplexValue {
  return obj.kind === 'ComplexValue';
}

export type OAuth2Flow =
  | OAuth2ImplicitFlow
  | OAuth2PasswordFlow
  | OAuth2ClientCredentialsFlow
  | OAuth2AuthorizationCodeFlow;

export function isOAuth2ImplicitFlow(
  obj: OAuth2Flow,
): obj is OAuth2ImplicitFlow {
  return obj.kind === 'OAuth2ImplicitFlow';
}

export function isOAuth2PasswordFlow(
  obj: OAuth2Flow,
): obj is OAuth2PasswordFlow {
  return obj.kind === 'OAuth2PasswordFlow';
}

export function isOAuth2ClientCredentialsFlow(
  obj: OAuth2Flow,
): obj is OAuth2ClientCredentialsFlow {
  return obj.kind === 'OAuth2ClientCredentialsFlow';
}

export function isOAuth2AuthorizationCodeFlow(
  obj: OAuth2Flow,
): obj is OAuth2AuthorizationCodeFlow {
  return obj.kind === 'OAuth2AuthorizationCodeFlow';
}

export type ObjectValidationRule =
  | ObjectMinPropertiesRule
  | ObjectMaxPropertiesRule
  | ObjectAdditionalPropertiesRule;

export function isObjectMinPropertiesRule(
  obj: ObjectValidationRule,
): obj is ObjectMinPropertiesRule {
  return obj.id === 'ObjectMinProperties';
}

export function isObjectMaxPropertiesRule(
  obj: ObjectValidationRule,
): obj is ObjectMaxPropertiesRule {
  return obj.id === 'ObjectMaxProperties';
}

export function isObjectAdditionalPropertiesRule(
  obj: ObjectValidationRule,
): obj is ObjectAdditionalPropertiesRule {
  return obj.id === 'ObjectAdditionalProperties';
}

/**
 * A single, fixed allowed value. This value MUST be compatible with the type
 * specified by `typeName`. When defined, this value is the only valid value for the
 * field, and tooling or validation MUST reject any other value.
 */
export type PrimitiveValueConstant =
  | StringLiteral
  | NumberLiteral
  | BooleanLiteral
  | NullLiteral;

/**
 * A value to be assumed or applied when none is provided. This value MUST be
 * compatible with the type specified by `typeName`. A default does not restrict
 * other valid values—it simply acts as the initial value when the field is omitted
 */
export type PrimitiveValueDefault =
  | StringLiteral
  | NumberLiteral
  | BooleanLiteral
  | NullLiteral;

/** A request id */
export type RequestId = string | number;

export type SecurityScheme = BasicScheme | ApiKeyScheme | OAuth2Scheme;

export function isBasicScheme(obj: SecurityScheme): obj is BasicScheme {
  return obj.kind === 'BasicScheme';
}

export function isApiKeyScheme(obj: SecurityScheme): obj is ApiKeyScheme {
  return obj.kind === 'ApiKeyScheme';
}

export function isOAuth2Scheme(obj: SecurityScheme): obj is OAuth2Scheme {
  return obj.kind === 'OAuth2Scheme';
}

/**
 * A Union is a type that can be one of several different types. The `members` array
 * contains the possible types that the Union can be.
 */
export type Union = SimpleUnion | DiscriminatedUnion;

export function isSimpleUnion(obj: Union): obj is SimpleUnion {
  return obj.kind === 'SimpleUnion';
}

export function isDiscriminatedUnion(obj: Union): obj is DiscriminatedUnion {
  return obj.kind === 'DiscriminatedUnion';
}

/** A validation rule. */
export type ValidationRule =
  | StringMaxLengthRule
  | StringMinLengthRule
  | StringPatternRule
  | StringFormatRule
  | NumberMultipleOfRule
  | NumberGtRule
  | NumberGteRule
  | NumberLtRule
  | NumberLteRule
  | ArrayMaxItemsRule
  | ArrayMinItemsRule
  | ArrayUniqueItemsRule;

export function isStringMaxLengthRule(
  obj: ValidationRule,
): obj is StringMaxLengthRule {
  return obj.id === 'StringMaxLength';
}

export function isStringMinLengthRule(
  obj: ValidationRule,
): obj is StringMinLengthRule {
  return obj.id === 'StringMinLength';
}

export function isStringPatternRule(
  obj: ValidationRule,
): obj is StringPatternRule {
  return obj.id === 'StringPattern';
}

export function isStringFormatRule(
  obj: ValidationRule,
): obj is StringFormatRule {
  return obj.id === 'StringFormat';
}

export function isNumberMultipleOfRule(
  obj: ValidationRule,
): obj is NumberMultipleOfRule {
  return obj.id === 'NumberMultipleOf';
}

export function isNumberGtRule(obj: ValidationRule): obj is NumberGtRule {
  return obj.id === 'NumberGT';
}

export function isNumberGteRule(obj: ValidationRule): obj is NumberGteRule {
  return obj.id === 'NumberGTE';
}

export function isNumberLtRule(obj: ValidationRule): obj is NumberLtRule {
  return obj.id === 'NumberLT';
}

export function isNumberLteRule(obj: ValidationRule): obj is NumberLteRule {
  return obj.id === 'NumberLTE';
}

export function isArrayMaxItemsRule(
  obj: ValidationRule,
): obj is ArrayMaxItemsRule {
  return obj.id === 'ArrayMaxItems';
}

export function isArrayMinItemsRule(
  obj: ValidationRule,
): obj is ArrayMinItemsRule {
  return obj.id === 'ArrayMinItems';
}

export function isArrayUniqueItemsRule(
  obj: ValidationRule,
): obj is ArrayUniqueItemsRule {
  return obj.id === 'ArrayUniqueItems';
}
